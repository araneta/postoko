import { Request, Response } from 'express';
import { getAuth } from '@clerk/express';
import { db } from '../db/index.js';
import { storeInfoTable, promotionsTable, discountCodesTable, promotionUsageTable, ordersTable, orderItemsTable, productsTable, categoriesTable } from '../db/schema.js';
import { eq, and, gte, lte, isNull, sql, inArray } from 'drizzle-orm';
import { v4 as uuidv4 } from 'uuid';

export class PromotionsController {
  // Create a new promotion
  static async createPromotion(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }

    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;

      const {
        name,
        description,
        type,
        discountValue,
        minimumPurchase,
        maximumDiscount,
        startDate,
        endDate,
        usageLimit,
        customerUsageLimit,
        isActive = true,
        applicableToCategories,
        applicableToProducts,
        discountCodes,
        // BOGO fields
        buyQuantity,
        getQuantity,
        getDiscountType,
        getDiscountValue,
        // Time-based fields
        timeBasedType,
        activeDays,
        activeTimeStart,
        activeTimeEnd,
        specificDates
      } = req.body;

      // Validate required fields
      const requiredFields = {
        name,
        type,
        discountValue,
        startDate,
        endDate,
      };

      const missingFields = Object.entries(requiredFields)
        .filter(([_, value]) => value === undefined || value === null || value === '')
        .map(([key]) => key);

      if (missingFields.length > 0) {
        return res.status(400).json({
          error: `Missing required field(s): ${missingFields.join(', ')}`,
          missingFields,
        });
      }

      // Validate promotion type
      if (!['percentage', 'fixed_amount', 'buy_x_get_y', 'time_based'].includes(type)) {
        return res.status(400).json({ error: 'Invalid promotion type' });
      }

      // Validate percentage discount
      if (type === 'percentage' && (discountValue < 0 || discountValue > 100)) {
        return res.status(400).json({ error: 'Percentage discount must be between 0 and 100' });
      }

      // Validate BOGO fields
      if (type === 'buy_x_get_y') {
        if (!buyQuantity || !getQuantity || !getDiscountType) {
          return res.status(400).json({ error: 'BOGO promotions require buyQuantity, getQuantity, and getDiscountType' });
        }
        if (!['free', 'percentage', 'fixed_amount'].includes(getDiscountType)) {
          return res.status(400).json({ error: 'Invalid getDiscountType for BOGO promotion' });
        }
        if (getDiscountType !== 'free' && !getDiscountValue) {
          return res.status(400).json({ error: 'getDiscountValue is required when getDiscountType is not "free"' });
        }
      }

      // Validate time-based fields
      if (type === 'time_based') {
        if (!timeBasedType || !activeTimeStart || !activeTimeEnd) {
          return res.status(400).json({ error: 'Time-based promotions require timeBasedType, activeTimeStart, and activeTimeEnd' });
        }
        if (!['daily', 'weekly', 'specific_dates'].includes(timeBasedType)) {
          return res.status(400).json({ error: 'Invalid timeBasedType' });
        }
      }

      const promotionId = uuidv4();

      // Create promotion
      const [promotion] = await db.insert(promotionsTable).values({
        id: promotionId,
        storeInfoId: storeInfoId,
        name,
        description: description || null,
        type: type as any,
        discountValue: parseFloat(discountValue.toString()),
        minimumPurchase: minimumPurchase ? parseFloat(minimumPurchase.toString()) : parseFloat('0.00'),
        maximumDiscount: maximumDiscount ? parseFloat(maximumDiscount.toString()) : null,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        usageLimit: usageLimit || null,
        usageCount: 0,
        customerUsageLimit: customerUsageLimit || 1,
        isActive,
        applicableToCategories: applicableToCategories ? applicableToCategories : null,
        applicableToProducts: applicableToProducts ? applicableToProducts : null,
        // BOGO fields
        buyQuantity: type === 'buy_x_get_y' ? buyQuantity : null,
        getQuantity: type === 'buy_x_get_y' ? getQuantity : null,
        getDiscountType: type === 'buy_x_get_y' ? (getDiscountType as any) : null,
        getDiscountValue: type === 'buy_x_get_y' && getDiscountValue ? parseFloat(getDiscountValue.toString()) : null,
        // Time-based fields
        timeBasedType: type === 'time_based' ? (timeBasedType as any) : null,
        activeDays: type === 'time_based' && activeDays ? activeDays : null,
        activeTimeStart: type === 'time_based' ? activeTimeStart : null,
        activeTimeEnd: type === 'time_based' ? activeTimeEnd : null,
        specificDates: type === 'time_based' && specificDates ? specificDates : null,
        createdAt: new Date(),
        updatedAt: new Date(),
        deletedAt: null
      }).returning();

      // Create discount codes if provided
      if (discountCodes && discountCodes.length > 0) {
        const codeInserts = discountCodes.map((code: string) => ({
          id: uuidv4(),
          promotionId,
          code: code.toUpperCase(),
          isActive: true,
          createdAt: new Date()
        }));

        await db.insert(discountCodesTable).values(codeInserts);
      }

      res.status(201).json({ promotion, message: 'Promotion created successfully' });
    } catch (error) {
      console.error('Error creating promotion:', error);
      res.status(500).json({ error: 'Failed to create promotion' });
    }
  }

  // Get all promotions for a store
  static async getPromotions(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }

    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(200).json([]);
      }
      const storeInfoId = storeInfo[0].id;

      const { active } = req.query;

      let whereConditions = and(
        eq(promotionsTable.storeInfoId, storeInfoId),
        isNull(promotionsTable.deletedAt)
      );

      if (active === 'true') {
        const now = new Date();
        whereConditions = and(
          eq(promotionsTable.storeInfoId, storeInfoId),
          eq(promotionsTable.isActive, true),
          lte(promotionsTable.startDate, now),
          gte(promotionsTable.endDate, now),
          isNull(promotionsTable.deletedAt)
        );
      }

      const promotions = await db.select()
        .from(promotionsTable)
        .where(whereConditions)
        .orderBy(promotionsTable.createdAt);

      // Get discount codes for each promotion
      const promotionsWithCodes = await Promise.all(
        promotions.map(async (promotion) => {
          const codes = await db.select({
            id: discountCodesTable.id,
            code: discountCodesTable.code,
            isActive: discountCodesTable.isActive,
            createdAt: discountCodesTable.createdAt
          })
            .from(discountCodesTable)
            .where(eq(discountCodesTable.promotionId, promotion.id));

          return {
            ...promotion,
            discountCodes: codes,
            applicableToCategories: promotion.applicableToCategories || [],
            applicableToProducts: promotion.applicableToProducts || [],
            activeDays: promotion.activeDays || [],
            specificDates: promotion.specificDates || []
          };
        })
      );

      res.json(promotionsWithCodes);
    } catch (error) {
      console.error('Error fetching promotions:', error);
      res.status(500).json({ error: 'Failed to fetch promotions' });
    }
  }

  // Get promotion by ID
  static async getPromotionById(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;

      const { id } = req.params;

      const [promotion] = await db.select()
        .from(promotionsTable)
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId)
        ));

      if (!promotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      const codes = await db.select({
        id: discountCodesTable.id,
        code: discountCodesTable.code,
        isActive: discountCodesTable.isActive,
        createdAt: discountCodesTable.createdAt
      })
        .from(discountCodesTable)
        .where(eq(discountCodesTable.promotionId, id));

      res.json({
        ...promotion,
        discountCodes: codes,
        applicableToCategories: promotion.applicableToCategories || [],
        applicableToProducts: promotion.applicableToProducts || [],
        activeDays: promotion.activeDays || [],
        specificDates: promotion.specificDates || []
      });
    } catch (error) {
      console.error('Error fetching promotion:', error);
      res.status(500).json({ error: 'Failed to fetch promotion' });
    }
  }

  // Check if promotion is applicable to a product
  static isPromotionApplicable(promotion: any, productId: string, categoryId: number): boolean {
    const applicableToProducts = promotion.applicableToProducts || [];
    const applicableToCategories = promotion.applicableToCategories || [];

    // If no specific products or categories, promotion applies to all
    if (applicableToProducts.length === 0 && applicableToCategories.length === 0) {
      return true;
    }

    // Check if product is explicitly included
    if (applicableToProducts.includes(productId)) {
      return true;
    }

    // Check if category is included
    if (applicableToCategories.includes(categoryId)) {
      return true;
    }

    return false;
  }

  // Calculate discount for different promotion types
  static calculateDiscount(promotion: any, items: any[], cartTotal: number): number {
    const discountType = promotion.type;
    const discountValue = parseFloat(promotion.discountValue || 0);
    const maximumDiscount = promotion.maximumDiscount ? parseFloat(promotion.maximumDiscount) : null;

    if (discountType === 'percentage') {
      let discount = (cartTotal * discountValue) / 100;
      if (maximumDiscount && discount > maximumDiscount) {
        discount = maximumDiscount;
      }
      return discount;
    } else if (discountType === 'fixed_amount') {
      let discount = discountValue;
      if (maximumDiscount && discount > maximumDiscount) {
        discount = maximumDiscount;
      }
      return Math.min(discount, cartTotal);
    } else if (discountType === 'buy_x_get_y') {
      return this.calculateBogoDiscount(promotion, items);
    }

    return 0;
  }

  // Calculate BOGO discount
  static calculateBogoDiscount(promotion: any, items: any[]): number {
    // Filter items applicable to this promotion
    const eligibleItems = items.filter(item =>
      this.isPromotionApplicable(promotion, item.productId, item.product.categoryId)
    );

    if (eligibleItems.length === 0) {
      return 0;
    }

    const buyQuantity = promotion.buyQuantity;
    const getQuantity = promotion.getQuantity;
    const getDiscountType = promotion.getDiscountType;
    const getDiscountValue = parseFloat(promotion.getDiscountValue || 0);

    // Sort items by price (descending) to apply discount to cheaper items first
    const sortedItems = [...eligibleItems].sort((a, b) =>
      parseFloat(b.product.price) - parseFloat(a.product.price)
    );

    let totalDiscount = 0;
    let remainingBuyQuantity = 0;

    for (const item of sortedItems) {
      const itemQuantity = item.quantity;
      const itemPrice = parseFloat(item.product.price);

      // Add to buy quantity
      remainingBuyQuantity += itemQuantity;

      // Calculate how many complete BOGO sets we can make
      const bogoSets = Math.floor(remainingBuyQuantity / (buyQuantity + getQuantity));

      if (bogoSets > 0) {
        const freeItems = bogoSets * getQuantity;

        if (getDiscountType === 'free') {
          totalDiscount += freeItems * itemPrice;
        } else if (getDiscountType === 'percentage') {
          totalDiscount += freeItems * itemPrice * (getDiscountValue / 100);
        } else if (getDiscountType === 'fixed_amount') {
          totalDiscount += freeItems * Math.min(getDiscountValue, itemPrice);
        }

        // Update remaining quantity
        remainingBuyQuantity -= bogoSets * (buyQuantity + getQuantity);
      }
    }

    return totalDiscount;
  }

  // Check if time-based promotion is currently active
  static isTimeBasedPromotionActive(promotion: any, currentTime: Date) {
    const timeBasedType = promotion.timeBasedType;
    const activeTimeStart = promotion.activeTimeStart;
    const activeTimeEnd = promotion.activeTimeEnd;

    // Check time of day
    const currentTimeStr = currentTime.toTimeString().substring(0, 8); // HH:MM:SS
    if (currentTimeStr < activeTimeStart || currentTimeStr > activeTimeEnd) {
      return false;
    }

    if (timeBasedType === 'daily') {
      // Active every day within the time range
      return true;
    } else if (timeBasedType === 'weekly') {
      // Check if current day is in activeDays
      const activeDays = promotion.activeDays || [];
      const currentDay = currentTime.getDay(); // 0 = Sunday, 1 = Monday, etc.
      return activeDays.includes(currentDay);
    } else if (timeBasedType === 'specific_dates') {
      // Check if current date is in specificDates
      const specificDates = promotion.specificDates || [];
      const currentDateStr = currentTime.toISOString().split('T')[0]; // YYYY-MM-DD
      return specificDates.includes(currentDateStr);
    }

    return false;
  }

  // Update promotion
  static async updatePromotion(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;
      const { id } = req.params;
      const { discountCodes, ...restBody } = req.body;

      const updateData: any = {
        ...restBody,
        updatedAt: new Date(),
      };

      // Convert date fields properly
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate);
      }

      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate);
      }

      // Convert numeric fields
      if (updateData.discountValue !== undefined) {
        updateData.discountValue = parseFloat(updateData.discountValue.toString());
      }

      if (updateData.minimumPurchase !== undefined) {
        updateData.minimumPurchase = parseFloat(updateData.minimumPurchase.toString());
      }

      if (updateData.maximumDiscount !== undefined) {
        updateData.maximumDiscount = parseFloat(updateData.maximumDiscount.toString());
      }

      if (updateData.getDiscountValue !== undefined) {
        updateData.getDiscountValue = parseFloat(updateData.getDiscountValue.toString());
      }

      // Remove fields that shouldn't be updated directly
      delete updateData.id;
      delete updateData.createdAt;
      delete updateData.usageCount;
      delete updateData.storeInfoId;
      delete updateData.deletedAt;

      const [updatedPromotion] = await db.update(promotionsTable)
        .set(updateData)
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId),
        ))
        .returning();

      if (!updatedPromotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      if (discountCodes) {
        // Delete old codes
        await db.delete(discountCodesTable)
          .where(eq(discountCodesTable.promotionId, id));

        // Insert new codes
        if (discountCodes.length > 0) {
          const codeInserts = discountCodes.map((code: string) => ({
            id: uuidv4(),
            promotionId: id,
            code: code.toUpperCase(),
            isActive: true,
            createdAt: new Date()
          }));

          await db.insert(discountCodesTable).values(codeInserts);
        }
      }

      res.json({ promotion: updatedPromotion, message: 'Promotion updated successfully' });
    } catch (error) {
      console.error('Error updating promotion:', error);
      res.status(500).json({ error: 'Failed to update promotion' });
    }
  }

  // Delete promotion (soft delete)
  static async deletePromotion(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;
      const { id } = req.params;

      const [deletedPromotion] = await db.update(promotionsTable)
        .set({ deletedAt: new Date() })
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId),
        ))
        .returning();

      if (!deletedPromotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      res.json({ message: 'Promotion deleted successfully' });
    } catch (error) {
      console.error('Error deleting promotion:', error);
      res.status(500).json({ error: 'Failed to delete promotion' });
    }
  }

  // Get promotion usage statistics
  static async getPromotionStats(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;
      const { id } = req.params;

      const [promotion] = await db.select()
        .from(promotionsTable)
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId),
        ));

      if (!promotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      // Get usage statistics
      const [usageStats] = await db.select({
        totalUsage: sql<number>`COUNT(*)`,
        totalDiscount: sql<number>`SUM(${promotionUsageTable.discountAmount})`,
        uniqueCustomers: sql<number>`COUNT(DISTINCT ${promotionUsageTable.customerId})`
      })
        .from(promotionUsageTable)
        .where(eq(promotionUsageTable.promotionId, id));

      res.json({
        promotion,
        stats: {
          totalUsage: usageStats.totalUsage || 0,
          totalDiscount: Number(usageStats.totalDiscount || 0),
          uniqueCustomers: usageStats.uniqueCustomers || 0,
          remainingUsage: promotion.usageLimit ? promotion.usageLimit - promotion.usageCount : null
        }
      });
    } catch (error) {
      console.error('Error fetching promotion stats:', error);
      res.status(500).json({ error: 'Failed to fetch promotion statistics' });
    }
  }

  // Validate discount code and calculate discount
  static async validateDiscountCode(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }

    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;

      const { code, customerId, orderItems, cartTotal } = req.body;

      // Validate required fields
      if (!code) {
        return res.status(400).json({ error: 'Missing required fields: code' });
      }
      if (!orderItems || !Array.isArray(orderItems) || orderItems.length === 0) {
        return res.status(400).json({ error: 'Missing required fields: orderItems (must be non-empty array)' });
      }
      if (cartTotal === undefined || cartTotal === null) {
        return res.status(400).json({ error: 'Missing required fields: cartTotal' });
      }

      // Find discount code with promotion
      const discountCodeRecords = await db.select({
        code: discountCodesTable.code,
        isActive: discountCodesTable.isActive,
        createdAt: discountCodesTable.createdAt,
        promotion: promotionsTable
      })
        .from(discountCodesTable)
        .innerJoin(promotionsTable, eq(discountCodesTable.promotionId, promotionsTable.id))
        .where(and(
          eq(discountCodesTable.code, code.toUpperCase()),
          eq(discountCodesTable.isActive, true),
          eq(promotionsTable.storeInfoId, storeInfoId),
          eq(promotionsTable.isActive, true),
          isNull(promotionsTable.deletedAt)
        ));

      if (!discountCodeRecords || discountCodeRecords.length === 0) {
        return res.status(404).json({ error: 'Invalid or inactive discount code' });
      }

      const discountCodeRecord = discountCodeRecords[0];
      const promotion = discountCodeRecord.promotion;
      const now = new Date();

      // Check if promotion is within date range
      const promotionStartDate = new Date(promotion.startDate);
      const promotionEndDate = new Date(promotion.endDate);

      if (now < promotionStartDate || now > promotionEndDate) {
        return res.status(400).json({
          error: 'Promotion is not currently active',
          details: {
            validFrom: promotionStartDate.toISOString(),
            validUntil: promotionEndDate.toISOString()
          }
        });
      }

      // Check time-based promotion constraints
      if (promotion.type === 'time_based') {
        const isTimeValid = this.isTimeBasedPromotionActive(promotion, now);
        if (!isTimeValid) {
          return res.status(400).json({ error: 'Promotion is not active at this time' });
        }
      }

      // Check global usage limit
      if (promotion.usageLimit && promotion.usageCount >= promotion.usageLimit) {
        return res.status(400).json({
          error: 'Promotion usage limit exceeded',
          details: {
            limit: promotion.usageLimit,
            current: promotion.usageCount
          }
        });
      }

      // Check customer usage limit
      if (customerId && promotion.customerUsageLimit) {
        const customerUsageRecords = await db.select({
          count: sql<number>`COUNT(*)`
        })
          .from(promotionUsageTable)
          .where(and(
            eq(promotionUsageTable.promotionId, promotion.id),
            eq(promotionUsageTable.customerId, customerId)
          ));

        if (customerUsageRecords && customerUsageRecords.length > 0) {
          const customerUsageCount = Number(customerUsageRecords[0].count || 0);
          if (customerUsageCount >= promotion.customerUsageLimit) {
            return res.status(400).json({
              error: 'Customer usage limit exceeded for this promotion',
              details: {
                limit: promotion.customerUsageLimit,
                current: customerUsageCount
              }
            });
          }
        }
      }

      // Check minimum purchase requirement
      const cartTotalNum = parseFloat(cartTotal.toString());
      if (promotion.minimumPurchase) {
        const minPurchaseNum = parseFloat(promotion.minimumPurchase.toString());
        if (cartTotalNum < minPurchaseNum) {
          return res.status(400).json({
            error: 'Minimum purchase not met',
            details: {
              required: minPurchaseNum,
              current: cartTotalNum,
              shortfall: minPurchaseNum - cartTotalNum
            }
          });
        }
      }

      // Filter eligible items based on promotion applicability
      let eligibleItems: any[] = [];

      if (promotion.applicableToProducts && Array.isArray(promotion.applicableToProducts) && promotion.applicableToProducts.length > 0) {
        eligibleItems = orderItems.filter(item =>
          promotion.applicableToProducts.includes(item.productId)
        );
      } else if (promotion.applicableToCategories && Array.isArray(promotion.applicableToCategories) && promotion.applicableToCategories.length > 0) {
        eligibleItems = orderItems.filter(item =>
          promotion.applicableToCategories.includes(item.categoryId)
        );
      } else {
        // Promotion applies to all items
        eligibleItems = orderItems;
      }

      if (eligibleItems.length === 0 && (promotion.applicableToProducts?.length > 0 || promotion.applicableToCategories?.length > 0)) {
        return res.status(400).json({ error: 'No eligible items for this promotion' });
      }

      // Calculate discount based on promotion type
      let discountAmount = 0;

      if (promotion.type === 'buy_x_get_y') {
        discountAmount = this.calculateBogoDiscount(promotion, orderItems);
      } else {
        // For percentage and fixed_amount
        discountAmount = this.calculateDiscount(promotion, orderItems, cartTotalNum);
      }

      if (discountAmount <= 0) {
        return res.status(400).json({ error: 'Promotion does not apply to this cart' });
      }

      res.status(200).json({
        valid: true,
        promotion: {
          id: promotion.id,
          name: promotion.name,
          description: promotion.description,
          type: promotion.type,
          discountValue: promotion.discountValue,
          maximumDiscount: promotion.maximumDiscount
        },
        discount: {
          amount: Number(discountAmount.toFixed(2)),
          type: promotion.type,
          discountValue: promotion.discountValue
        },
        summary: {
          cartTotal: cartTotalNum,
          discountAmount: Number(discountAmount.toFixed(2)),
          finalTotal: Number((cartTotalNum - discountAmount).toFixed(2)),
          eligibleItemCount: eligibleItems.length
        }
      });
    } catch (error) {
      console.error('Error validating discount code:', error);
      res.status(500).json({ error: 'Failed to validate discount code' });
    }
  }
}
