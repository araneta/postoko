import { Request, Response } from 'express';
import { getAuth } from '@clerk/express';
import { db } from '../db/index.js';
import { storeInfoTable, promotionsTable, discountCodesTable, promotionUsageTable, ordersTable, orderItemsTable, productsTable, categoriesTable } from '../db/schema.js';
import { eq, and, gte, lte, isNull, sql, inArray } from 'drizzle-orm';
import { v4 as uuidv4 } from 'uuid';

export class PromotionsController {
  // Create a new promotion
  static async createPromotion(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }

    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;

      const {
        name,
        description,
        type,
        discountValue,
        minimumPurchase,
        maximumDiscount,
        startDate,
        endDate,
        usageLimit,
        customerUsageLimit,
        isActive = true,
        applicableToCategories,
        applicableToProducts,
        discountCodes,
        // BOGO fields
        buyQuantity,
        getQuantity,
        getDiscountType,
        getDiscountValue,
        // Time-based fields
        timeBasedType,
        activeDays,
        activeTimeStart,
        activeTimeEnd,
        specificDates
      } = req.body;

      // Validate required fields
      const requiredFields = {
        name,
        type,
        discountValue,
        startDate,
        endDate,
      };

      const missingFields = Object.entries(requiredFields)
        .filter(([_, value]) => value === undefined || value === null || value === '')
        .map(([key]) => key);

      if (missingFields.length > 0) {
        return res.status(400).json({
          error: `Missing required field(s): ${missingFields.join(', ')}`,
          missingFields,
        });
      }

      // Validate promotion type
      if (!['percentage', 'fixed_amount', 'buy_x_get_y', 'time_based'].includes(type)) {
        return res.status(400).json({ error: 'Invalid promotion type' });
      }

      // Validate percentage discount
      if (type === 'percentage' && (discountValue < 0 || discountValue > 100)) {
        return res.status(400).json({ error: 'Percentage discount must be between 0 and 100' });
      }

      // Validate BOGO fields
      if (type === 'buy_x_get_y') {
        if (!buyQuantity || !getQuantity || !getDiscountType) {
          return res.status(400).json({ error: 'BOGO promotions require buyQuantity, getQuantity, and getDiscountType' });
        }
        if (!['free', 'percentage', 'fixed_amount'].includes(getDiscountType)) {
          return res.status(400).json({ error: 'Invalid getDiscountType for BOGO promotion' });
        }
        if (getDiscountType !== 'free' && !getDiscountValue) {
          return res.status(400).json({ error: 'getDiscountValue is required when getDiscountType is not "free"' });
        }
      }

      // Validate time-based fields
      if (type === 'time_based') {
        if (!timeBasedType || !activeTimeStart || !activeTimeEnd) {
          return res.status(400).json({ error: 'Time-based promotions require timeBasedType, activeTimeStart, and activeTimeEnd' });
        }
        if (!['daily', 'weekly', 'specific_dates'].includes(timeBasedType)) {
          return res.status(400).json({ error: 'Invalid timeBasedType' });
        }
      }

      const promotionId = uuidv4();

      // Create promotion
      const [promotion] = await db.insert(promotionsTable).values({
        id: promotionId,
        storeInfoId: storeInfoId,
        name,
        description: description || null,
        type: type as any,
        discountValue: parseFloat(discountValue.toString()),
        minimumPurchase: minimumPurchase ? parseFloat(minimumPurchase.toString()) : parseFloat('0.00'),
        maximumDiscount: maximumDiscount ? parseFloat(maximumDiscount.toString()) : null,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        usageLimit: usageLimit || null,
        usageCount: 0,
        customerUsageLimit: customerUsageLimit || 1,
        isActive,
        applicableToCategories: applicableToCategories ? applicableToCategories : null,
        applicableToProducts: applicableToProducts ? applicableToProducts : null,
        // BOGO fields
        buyQuantity: type === 'buy_x_get_y' ? buyQuantity : null,
        getQuantity: type === 'buy_x_get_y' ? getQuantity : null,
        getDiscountType: type === 'buy_x_get_y' ? (getDiscountType as any) : null,
        getDiscountValue: type === 'buy_x_get_y' && getDiscountValue ? parseFloat(getDiscountValue.toString()) : null,
        // Time-based fields
        timeBasedType: type === 'time_based' ? (timeBasedType as any) : null,
        activeDays: type === 'time_based' && activeDays ? activeDays : null,
        activeTimeStart: type === 'time_based' ? activeTimeStart : null,
        activeTimeEnd: type === 'time_based' ? activeTimeEnd : null,
        specificDates: type === 'time_based' && specificDates ? specificDates : null,
        createdAt: new Date(),
        updatedAt: new Date(),
        deletedAt: null
      }).returning();

      // Create discount codes if provided
      if (discountCodes && discountCodes.length > 0) {
        const codeInserts = discountCodes.map((code: string) => ({
          id: uuidv4(),
          promotionId,
          code: code.toUpperCase(),
          isActive: true,
          createdAt: new Date()
        }));

        await db.insert(discountCodesTable).values(codeInserts);
      }

      res.status(201).json({ promotion, message: 'Promotion created successfully' });
    } catch (error) {
      console.error('Error creating promotion:', error);
      res.status(500).json({ error: 'Failed to create promotion' });
    }
  }

  // Get all promotions for a store
  static async getPromotions(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }

    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(200).json([]);
      }
      const storeInfoId = storeInfo[0].id;

      const { active } = req.query;

      let whereConditions = and(
        eq(promotionsTable.storeInfoId, storeInfoId),
        isNull(promotionsTable.deletedAt)
      );

      if (active === 'true') {
        const now = new Date();
        whereConditions = and(
          eq(promotionsTable.storeInfoId, storeInfoId),
          eq(promotionsTable.isActive, true),
          lte(promotionsTable.startDate, now),
          gte(promotionsTable.endDate, now),
          isNull(promotionsTable.deletedAt)
        );
      }

      const promotions = await db.select()
        .from(promotionsTable)
        .where(whereConditions)
        .orderBy(promotionsTable.createdAt);

      // Get discount codes for each promotion
      const promotionsWithCodes = await Promise.all(
        promotions.map(async (promotion) => {
          const codes = await db.select({
            id: discountCodesTable.id,
            code: discountCodesTable.code,
            isActive: discountCodesTable.isActive,
            createdAt: discountCodesTable.createdAt
          })
            .from(discountCodesTable)
            .where(eq(discountCodesTable.promotionId, promotion.id));

          return {
            ...promotion,
            discountCodes: codes,
            applicableToCategories: promotion.applicableToCategories || [],
            applicableToProducts: promotion.applicableToProducts || [],
            activeDays: promotion.activeDays || [],
            specificDates: promotion.specificDates || []
          };
        })
      );

      res.json(promotionsWithCodes);
    } catch (error) {
      console.error('Error fetching promotions:', error);
      res.status(500).json({ error: 'Failed to fetch promotions' });
    }
  }

  // Get promotion by ID
  static async getPromotionById(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;

      const { id } = req.params;

      const [promotion] = await db.select()
        .from(promotionsTable)
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId)
        ));

      if (!promotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      const codes = await db.select({
        id: discountCodesTable.id,
        code: discountCodesTable.code,
        isActive: discountCodesTable.isActive,
        createdAt: discountCodesTable.createdAt
      })
        .from(discountCodesTable)
        .where(eq(discountCodesTable.promotionId, id));

      res.json({
        ...promotion,
        discountCodes: codes,
        applicableToCategories: promotion.applicableToCategories || [],
        applicableToProducts: promotion.applicableToProducts || [],
        activeDays: promotion.activeDays || [],
        specificDates: promotion.specificDates || []
      });
    } catch (error) {
      console.error('Error fetching promotion:', error);
      res.status(500).json({ error: 'Failed to fetch promotion' });
    }
  }

  

  // Calculate discount for different promotion types
  static calculateDiscount(promotion: any, items: any[], cartTotal: number): number {
    const discountType = promotion.type;
    const discountValue = parseFloat(promotion.discountValue || 0);
    const maximumDiscount = promotion.maximumDiscount ? parseFloat(promotion.maximumDiscount) : null;

    if (discountType === 'percentage') {
      let discount = (cartTotal * discountValue) / 100;
      if (maximumDiscount && discount > maximumDiscount) {
        discount = maximumDiscount;
      }
      return discount;
    } else if (discountType === 'fixed_amount') {
      let discount = discountValue;
      if (maximumDiscount && discount > maximumDiscount) {
        discount = maximumDiscount;
      }
      return Math.min(discount, cartTotal);
    } else if (discountType === 'buy_x_get_y') {
      return this.calculateBogoDiscount(promotion, items);
    }

    return 0;
  }

  // Calculate BOGO discount
  static calculateBogoDiscount(promotion: any, items: any[]): number {
    // Filter items applicable to this promotion
    const eligibleItems = items.filter(item =>
      this.isPromotionApplicable(promotion, item.productId, item.product.categoryId)
    );

    if (eligibleItems.length === 0) {
      return 0;
    }

    const buyQuantity = promotion.buyQuantity;
    const getQuantity = promotion.getQuantity;
    const getDiscountType = promotion.getDiscountType;
    const getDiscountValue = parseFloat(promotion.getDiscountValue || 0);

    // Sort items by price (descending) to apply discount to cheaper items first
    const sortedItems = [...eligibleItems].sort((a, b) =>
      parseFloat(b.product.price) - parseFloat(a.product.price)
    );

    let totalDiscount = 0;
    let remainingBuyQuantity = 0;

    for (const item of sortedItems) {
      const itemQuantity = item.quantity;
      const itemPrice = parseFloat(item.product.price);

      // Add to buy quantity
      remainingBuyQuantity += itemQuantity;

      // Calculate how many complete BOGO sets we can make
      const bogoSets = Math.floor(remainingBuyQuantity / (buyQuantity + getQuantity));

      if (bogoSets > 0) {
        const freeItems = bogoSets * getQuantity;

        if (getDiscountType === 'free') {
          totalDiscount += freeItems * itemPrice;
        } else if (getDiscountType === 'percentage') {
          totalDiscount += freeItems * itemPrice * (getDiscountValue / 100);
        } else if (getDiscountType === 'fixed_amount') {
          totalDiscount += freeItems * Math.min(getDiscountValue, itemPrice);
        }

        // Update remaining quantity
        remainingBuyQuantity -= bogoSets * (buyQuantity + getQuantity);
      }
    }

    return totalDiscount;
  }

  // Check if time-based promotion is currently active
  static isTimeBasedPromotionActive(promotion: any, currentTime: Date) {
    const timeBasedType = promotion.timeBasedType;
    const activeTimeStart = promotion.activeTimeStart;
    const activeTimeEnd = promotion.activeTimeEnd;

    // Check time of day
    const currentTimeStr = currentTime.toTimeString().substring(0, 8); // HH:MM:SS
    if (currentTimeStr < activeTimeStart || currentTimeStr > activeTimeEnd) {
      return false;
    }

    if (timeBasedType === 'daily') {
      // Active every day within the time range
      return true;
    } else if (timeBasedType === 'weekly') {
      // Check if current day is in activeDays
      const activeDays = promotion.activeDays || [];
      const currentDay = currentTime.getDay(); // 0 = Sunday, 1 = Monday, etc.
      return activeDays.includes(currentDay);
    } else if (timeBasedType === 'specific_dates') {
      // Check if current date is in specificDates
      const specificDates = promotion.specificDates || [];
      const currentDateStr = currentTime.toISOString().split('T')[0]; // YYYY-MM-DD
      return specificDates.includes(currentDateStr);
    }

    return false;
  }

  // Update promotion
  static async updatePromotion(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;
      const { id } = req.params;
      const { discountCodes, ...restBody } = req.body;

      const updateData: any = {
        ...restBody,
        updatedAt: new Date(),
      };

      // Convert date fields properly
      if (updateData.startDate) {
        updateData.startDate = new Date(updateData.startDate);
      }

      if (updateData.endDate) {
        updateData.endDate = new Date(updateData.endDate);
      }

      // Convert numeric fields
      if (updateData.discountValue !== undefined) {
        updateData.discountValue = parseFloat(updateData.discountValue.toString());
      }

      if (updateData.minimumPurchase !== undefined) {
        updateData.minimumPurchase = parseFloat(updateData.minimumPurchase.toString());
      }

      if (updateData.maximumDiscount !== undefined) {
        updateData.maximumDiscount = parseFloat(updateData.maximumDiscount.toString());
      }

      if (updateData.getDiscountValue !== undefined) {
        updateData.getDiscountValue = parseFloat(updateData.getDiscountValue.toString());
      }

      // Remove fields that shouldn't be updated directly
      delete updateData.id;
      delete updateData.createdAt;
      delete updateData.usageCount;
      delete updateData.storeInfoId;
      delete updateData.deletedAt;

      const [updatedPromotion] = await db.update(promotionsTable)
        .set(updateData)
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId),
        ))
        .returning();

      if (!updatedPromotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      if (discountCodes) {
        // Delete old codes
        await db.delete(discountCodesTable)
          .where(eq(discountCodesTable.promotionId, id));

        // Insert new codes
        if (discountCodes.length > 0) {
          const codeInserts = discountCodes.map((code: string) => ({
            id: uuidv4(),
            promotionId: id,
            code: code.toUpperCase(),
            isActive: true,
            createdAt: new Date()
          }));

          await db.insert(discountCodesTable).values(codeInserts);
        }
      }

      res.json({ promotion: updatedPromotion, message: 'Promotion updated successfully' });
    } catch (error) {
      console.error('Error updating promotion:', error);
      res.status(500).json({ error: 'Failed to update promotion' });
    }
  }

  // Delete promotion (soft delete)
  static async deletePromotion(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;
      const { id } = req.params;

      const [deletedPromotion] = await db.update(promotionsTable)
        .set({ deletedAt: new Date() })
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId),
        ))
        .returning();

      if (!deletedPromotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      res.json({ message: 'Promotion deleted successfully' });
    } catch (error) {
      console.error('Error deleting promotion:', error);
      res.status(500).json({ error: 'Failed to delete promotion' });
    }
  }

  // Get promotion usage statistics
  static async getPromotionStats(req: Request, res: Response) {
    const auth = getAuth(req);
    if (!auth.userId) {
      return res.status(401).send('Unauthorized');
    }
    try {
      const storeInfo = await db.select()
        .from(storeInfoTable)
        .where(eq(storeInfoTable.userId, auth.userId));
      if (storeInfo.length === 0) {
        return res.status(400).json({ error: 'Store information not found' });
      }
      const storeInfoId = storeInfo[0].id;
      const { id } = req.params;

      const [promotion] = await db.select()
        .from(promotionsTable)
        .where(and(
          eq(promotionsTable.id, id),
          isNull(promotionsTable.deletedAt),
          eq(promotionsTable.storeInfoId, storeInfoId),
        ));

      if (!promotion) {
        return res.status(404).json({ error: 'Promotion not found' });
      }

      // Get usage statistics
      const [usageStats] = await db.select({
        totalUsage: sql<number>`COUNT(*)`,
        totalDiscount: sql<number>`SUM(${promotionUsageTable.discountAmount})`,
        uniqueCustomers: sql<number>`COUNT(DISTINCT ${promotionUsageTable.customerId})`
      })
        .from(promotionUsageTable)
        .where(eq(promotionUsageTable.promotionId, id));

      res.json({
        promotion,
        stats: {
          totalUsage: usageStats.totalUsage || 0,
          totalDiscount: Number(usageStats.totalDiscount || 0),
          uniqueCustomers: usageStats.uniqueCustomers || 0,
          remainingUsage: promotion.usageLimit ? promotion.usageLimit - promotion.usageCount : null
        }
      });
    } catch (error) {
      console.error('Error fetching promotion stats:', error);
      res.status(500).json({ error: 'Failed to fetch promotion statistics' });
    }
  }
}
